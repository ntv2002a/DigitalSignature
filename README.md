# **Using Digital Signature with JAVA**

# Requirement
* Apache NetBeans IDE 13
* JDK 1.8

# Usage
## ***Generating a Digital Signature***
---
* Import some library needed for Hashing
```Java
import java.io.BufferedInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.security.*;
```
---

### **Generate Public and Private Keys**
* In order to be able to create a digital signature, you need a private key.

* In some cases the key pair (private key and corresponding public key) are already available in files.

* In other cases the program needs to generate the key pair. A key pair is generated by using the `KeyPairGenerator` class.

* In this example you will generate a public/private key pair for the Digital Signature Algorithm (DSA). You will generate keys with a 1024-bit length.

* Create a Key Pair Generator
    - The first step is to get a key-pair generator object for generating keys for the DSA signature algorithm.

    - As with all engine classes, the way to get a KeyPairGenerator object for a particular type of algorithm is to call the getInstance static factory method on the KeyPairGenerator class. This method has two forms, both of which hava a String algorithm first argument; one form also has a String provider second argument.
    ```Java
    KeyPairGenerator keyGen = KeyPairGenerator.getInstance("DSA", "SUN");
    ```

* Initialize the Key Pair Generator
    - The next step is to initialize the key pair generator. All key pair generators share the concepts of a keysize and a source of randomness. The `KeyPairGenerator` class has an `initialize()` method that takes these two types of arguments.

    - The following example requests an instance of `SecureRandom` that uses the SHA1PRNG algorithm, as provided by the built-in SUN provider.

    ```Java
    SecureRandom random = SecureRandom.getInstance("SHA1PRNG", "SUN");
    keyGen.initialize(1024, random);
    ```

* Generate the Pair of Keys
    - The final step is to generate the key pair and to store the keys in `PrivateKey` and `PublicKey` objects.

    ```Java
    KeyPair pair = keyGen.generateKeyPair();
    PrivateKey priv = pair.getPrivate();
    PublicKey pub = pair.getPublic();
    ```
---
### **Sign the Data**

Now that you have created a public key and a private key, you are ready to sign the data. In this example you will sign the data contained in a file. GenSig gets the file name from the command line. A digital signature is created (or verified) using an instance of the `Signature` class.

* Get a Signature Object

    The following gets a Signature object for generating or verifying signatures using the DSA algorithm, the same algorithm for which the program generated keys in the previous step

```Java
    Signature dsa = Signature.getInstance("SHA1withDSA", "SUN"); 
```

* Initialize the Signature Object

    Before a `Signature` object can be used for signing or verifying, it must be initialized. The initialization method for signing requires a private key. Use the private key placed into the `PrivateKey` object named `priv` in the previous step.

```Java
    dsa.initSign(priv);
```

* Supply the Signature Object the Data to Be Signed

    This program will use the data from the file whose name is specified as the first (and only) command line argument. The program will read in the data a buffer at a time and will supply it to the `Signature` object by calling the `update()` method.

```Java
    FileInputStream fis = new FileInputStream(DataNameFile);
    BufferedInputStream bufin = new BufferedInputStream(fis);
    byte[] buffer = new byte[1024];
    int len;
    while ((len = bufin.read(buffer)) >= 0) {
        dsa.update(buffer, 0, len);
    };
    bufin.close();
```
* Generate the Signature

    Once all of the data has been supplied to the `Signature` object, you can generate the digital signature of that data.

```Java
    byte[] realSig = dsa.sign();
```

---
### **Save the Signature and the Public Key in Files**
Now that you have generated a signature for some data, you need to save the signature bytes in one file and the public key bytes in another so you can send (via modem, floppy, mail, and so on) someone else

* *the data for which the signature was generated*
* *the signature*
* *the public key*

The receiver can verify that the data came from you and was not modified in transit by running the *VerSig* program you will generate in the upcoming *Verifying a Digital Signature* steps. That program uses the public key to verify that the signature received is the true signature for the data received.

* Recall that the signature was placed in a byte array named `realSig`. You can save the signature bytes in a file named *Signature* via the following.

```Java
    // save the signature in a file
    FileOutputStream sigfos = new FileOutputStream(SignatureFileName);
    sigfos.write(realSig);
    sigfos.close();
```

* Recall from the *Generate Public and Private Keys* step that the public key was placed in a `PublicKey` object named `pub`. You can get the encoded key bytes by calling the `getEncoded()` method and then store the encoded bytes in a file. You can name the file whatever you want.

```Java
    // save the public key in a file
    byte[] key = pub.getEncoded();
    FileOutputStream keyfos = new FileOutputStream(PublicKeyFileName);
    keyfos.write(key);
    keyfos.close();
```

---
***-> It's all about Generating a Digital Signature by the most basic way with Java.
After executing the `GenSig` program you should see the saved `PublicKeyFileName` (public key) and `SignatureFileName` (signature) files.***

---

## ***Verifying a Digital Signature***

* Import some library needed for Verifting a Digital Signature
```Java
import java.io.BufferedInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.security.*;
import java.security.spec.X509EncodedKeySpec;
```

If you have data for which a digital signature was generated, you can verify the authenticity of the signature. To do so, you need

* *the data*
* *the signature*
* *the public key corresponding to the private key used to sign the data*

---
### **Input and Convert the Encoded Public Key Bytes**

Next, `VerSig` needs to import the encoded public key bytes from the file specified as the first command line argument and to convert them to a `PublicKey`. A `PublicKey` is needed because that is what the `Signature` initVerify method requires in order to initialize the Signature object for verification.

* First, read in the encoded public key bytes.

```Java
    FileInputStream keyfis = new FileInputStream(PublicKeyFileName);
    byte[] encKey = new byte[keyfis.available()];  
    keyfis.read(encKey);

    keyfis.close();
```

* Now the byte array `encKey` contains the encoded public key bytes.

*You can use a `KeyFactory` class in order to instantiate a **DSA** public key from its encoding. The `KeyFactory` class provides conversions between opaque keys (of type Key) and key specifications, which are transparent representations of the underlying key material. With an opaque key you can obtain the algorithm name, format name, and encoded key bytes, but not the key material, which, for example, may consist of the key itself and the algorithm parameters used to calculate the key. (Note that `PublicKey`, because it extends `Key`, is itself a `Key`.)*

* So, first you need a key specification. You can obtain one via the following, assuming that the key was encoded according to the **`X.509`** standard, which is the case, for example, if the key was generated with the built-in **DSA** key-pair generator supplied by the **SUN** provider:

```Java
    X509EncodedKeySpec pubKeySpec = new X509EncodedKeySpec(encKey);
```

* Now you need a `KeyFactory` object to do the conversion. That object must be one that works with **DSA** keys.

```Java
    KeyFactory keyFactory = KeyFactory.getInstance("DSA", "SUN");
```

* Finally, you can use the `KeyFactory` object to generate a `PublicKey` from the key specification.

```Java
    PublicKey pubKey = keyFactory.generatePublic(pubKeySpec);
```

---
### **Input the Signature Bytes**

* Next, input the signature bytes from the file specified as the second command line argument.

```Java
    FileInputStream sigfis = new FileInputStream(SignatureFileName);
    byte[] sigToVerify = new byte[sigfis.available()]; 
    sigfis.read(sigToVerify);
    sigfis.close();
```

*Now the byte array sigToVerify contains the signature bytes*

---
### **Verify the Signature**

* Initialize the Signature Object for Verification

As with signature generation, a signature is verified by using an instance of the `Signature` class. You need to create a `Signature` object that uses the same signature algorithm as was used to generate the signature. The algorithm used by the `GenSig` program was the `SHA1withDSA` algorithm from the **SUN** provider.

```Java
    Signature sig = Signature.getInstance("SHA1withDSA", "SUN");
```

Next, you need to initialize the `Signature` object. The initialization method for verification requires the public key.

```Java
    sig.initVerify(pubKey);
```

* Supply the Signature Object With the Data to be Verified

You now need to supply the `Signature` object with the data for which a signature was generated. This data is in the file whose name was specified as the third command line argument. As you did when signing, read in the data one buffer at a time, and supply it to the `Signature` object by calling the `update()` method.

```Java
    FileInputStream datafis = new FileInputStream(DataFileName);
    BufferedInputStream bufin = new BufferedInputStream(datafis);

    byte[] buffer = new byte[1024];
    int len;
    while (bufin.available() != 0) {
        len = bufin.read(buffer);
        sig.update(buffer, 0, len);
    };

    bufin.close();
```

* Verify the Signature

Once you have supplied all of the data to the `Signature` object, you can verify the digital signature of that data and report the result. Recall that the alleged signature was read into a byte array called `sigToVerify`.

```Java
    boolean verifies = sig.verify(sigToVerify);

    System.out.println("Signature verifies: " + verifies);
```

*The `verifies` value will be true if the alleged signature (`sigToVerify`) is the actual signature of the specified data file generated by the private key corresponding to the public key `pubKey`.*

---
***-> It's all about Verifying a Digital Signature by the most basic way with Java.
After executing the `VerSig`, if your PublicKey, Signature and DataFile that you receiveds are all `authenticated` the result that you have before running `VerSig` program is `true`.***

For example:
```
    Signature verifies: true
```

---

## About
* [Generating and Verifying Signatures](https://docs.oracle.com/javase/tutorial/security/apisign/index.html)
* [Weaknesses and Alternatives](https://docs.oracle.com/javase/tutorial/security/apisign/enhancements.html)